% This is an included file. See the master file for more information.
%

\section{OCR objects}
\label{sec:OCRobjects}


An OCR object is a reference counted entity managed by OCR. Every OCR
object has a globally unique ID (GUID) used to identify the
object. An OCR program is defined in terms of three fundamental objects.
\begin{itemize}
\item \emph{Event Driven Task (EDT)}: A non-blocking unit of work in an OCR
program.
\item\emph{Data block (DB)}: A contiguous block of memory managed by the
OCR runtime accessible to any OCR objects to which it is linked.
\item\emph{Event}: An object to manage dependences between OCR objects and
to define ordering relationships (synchronization) between them.
\end{itemize}

In addition to these fundamental objects, other OCR objects
play a supporting role; making programming more convenient or
to provide information the OCR runtime can use to optimize program execution.
%\begin{description}
\begin{itemize}
\item \emph{EDT Template} An OCR object used to manage the resources
required to create an EDT.
\item \emph{Affinity container} An OCR object used to influence the
placement of EDTs in an executing program.
\end{itemize}

Objects have two well defined states.
\begin{enumerate}
\item \emph{Created}: Resources associated with an object and its GUID
have been created.
\item \emph{Destroyed}: An object that is destroyed is marked for
destruction when the destruction command executes. A destroyed object, its GUID,
and any resources associated with the destroyed object are no longer
defined. The object is not actually destroyed and the associated
resources are not freed until the reference count is zero\footnote{As
an optimization, the runtime may choose to reuse the same physical
object for different logical objects~\cite{USBCSS12,SbKS12}.}.
%
%  Vivek suggest we call this "Dead" instead of "destroyed".  He provided new text in his feedback to
% address this. I would have put his text here, but I can't cut and paste from his document. But
% if we all agree, we should look at his feedback document and add this later.
\end{enumerate}
Furthermore, for OCR data blocks, we have two additional states:
\begin{enumerate}
\item \emph{Acquired}: the data associated with the data block has
become accessible to the acquiring OCR object thereby incrementing the
acquired objects reference count.
\item \emph{Released}: The object is no longer accessible by the OCR
object that had earlier acquired it. The reference count on the
released object is decremented.
\end{enumerate}



\subsection{Dependences, Links and slots}
\index{OCR links}
\label{sec:OCRlinks}

An OCR program is defined as a directed acyclic graph
with EDTs and Events as nodes and edges that define
\emph{links}\index{Link} between objects. A link defines a dependence
between OCR objects. The links are defined in terms of
\emph{slots}\index{Slot} on the OCR object which define an end
point for a dependence.
There are two
types of slots, \emph{pre-slots} and \emph{post-slots}.   A pre-slot defines the prerequisites for
an OCR object while the post-slot is used to communicate results from an OCR object.

Event, data blocks and EDTs each have a
single \emph{post-slot}\index{post-slot}.
For example, when an EDT finishes the work
assigned to it, the EDT sets its post-slot to the state \emph{satisfied}.
This triggers any links between that EDT's post-slot and the pre-slot of later OCR
objects in the program DAG.  The rules
defining when a post-slot triggers, the so-called \emph{post-slot
trigger rule}\index{post-slot trigger rule} depends on the type of OCR
object and is discussed in Section~\ref{sec:Event}.

Some OCR objects (such as EDTs) may also have an optional set of
\emph{pre-slots}\index{pre-slot}. A pre-slot defines an incoming
dependence or a pre-condition for execution by an EDT. The post-slot
of one EDT, for example, can be connected to the pre-slot of another
EDT thereby establishing a control dependence\index{control
dependence} between the EDTs. Likewise,
the post-slot of a data block can be connected to the pre-slot of an EDT
to establish an immediately satisfied data dependence.

Slots are used along with data blocks to define data
dependences\index{data dependence} between OCR objects. For example,
consider a producer consumer relationships\index{producer consumer
relationships} between a pair of EDTs.  The post-slot of the producer EDT is connected to
the pre-slot of the consumer EDT. When the producer finishes its work
and updates the data block it wishes to share, it associates that data
block with its post-slot and changes the post-slot's state to ``satisfied''.  This triggers
the link between the producer and the consumer making the data block
available to the consumer; who can now safely use the data block from
the producer.

Slots can take-on the following states.
\begin{itemize}
\item Unconnected: There are no links connecting to the slot;
\item Connected: a link attaches a source post-slot to a destination pre-slot.
\end{itemize}
A slot in the \emph{connected} state can be:
\begin{itemize}
\item Satisfied: the source of the link has been triggered;
%\item Triggered: see 'Trigger';
\item Unsatisfied: the source of the link has not been triggered.
\end{itemize}

All slots are initially in the \code{unconnected} state. Data
block post-slots are immediately \code{satisfied} as soon as they are
connected.

\subsection{Event Driven Task (EDT)}
\index{EDT}
\label{sec:EDT}

The fundamental unit of work in OCR is
the \emph{Event Driven Task} \index{Event Driven Task}or \emph{EDT}.
When all pre-conditions on an EDT have been met it becomes a runnable EDT.
Later when its
input data blocks are acquired, the EDT is ready to ready to execute.  The OCR
runtime guarantees that a runnable EDT will execute at some point and once running,
the EDT will progress to its terminal state
and cannot be halted by the action of other OCR objects; hence why the
execution of an EDT is said to be \emph{non-blocking}.

The work carried out by an EDT is defined by
the \emph{EDT function}\index{EDT function}. The EDT function prototype
and return values are defined in the OCR API (see section~\ref{group__OCREDT}).
\begin{itemize}
\item The parameters of the EDT function which are copied by value
when the EDT is created.
\item Dynamic dependences expressed through a dependence array that is
formed at runtime from explicit user-specified dependences.
\item An optional GUID of a OCR object holding data (a \emph{data
block}) that will be used to satisfy the EDTâ€™s post-slot. This is the
return value of the function.
\end{itemize}

When the OCR API is used to create an EDT (using the \code{ocrEdtCreate()} function)
one or two GUIDs are created.  The first (always returned) is the GUID for the EDT itself.
The second (returned only on programmer request) is the GUID of the
event implied by the post-slot of the EDT\footnote{It is important to
note that although, semantically, an EDT can be the source of a
dependence, when adding a dependence, the programmer must use the
GUID of the associated event as the source.}
When the OCR function returns a data block, the GUID of
that data block is used to satisfy this implied event.

Using a post-slot in a link to another object is just one method to
trigger other OCR objects. OCR includes the \code{ocrEventSatisfy()}
function to trigger other OCR objects through explicitly created dependence
links.  The OCR runtime, however, is allowed to defer all event satisfactions
to the end of the EDT.  This is an important performance optimization designed
into OCR.   This is also consistent with the intent of OCR to define the state
of an evolving computation by the versions of data blocks and a log of the
EDTs that have completed.   This implies that an OCR programmer should
ideally treat EDTs as small units of work that execute with transactional
semantics.

OCR defines one special type of EDT; the \emph{finish
EDT}\index{Finish EDT}. An EDT always executes asynchronously and
without blocking once all of its pre-conditions have been met. A
finish EDT, however, will not trigger its post-slot until all EDTs
launched within its scope (i.e.\ its child EDTs and EDTs created
within its child EDTs) have completed.  The finish EDT still executes
asynchronously and without blocking. The implied event associated with
the post-slot of a finish EDT is a \emph{latch event}, i.e.\ it is
connected to the post-slots of all EDTs created within its scope and
does not trigger until they have all finished.

For both normal and finish EDTs, the EDT is created as an
instance of  an \emph{EDT template}\index{EDT
template}. This template stores metadata about EDTs created from the
template, optionally defines the number of dependences and parameters
used when creating an instance of an EDT, and is a container for the
function that will be executed by an EDT. This function is called the
\emph{EDT function}\index{EDT function}.

\subsection{Events}
\index{Event}
\label{sec:Event}

An event is an OCR object used to coordinate the activity of other OCR
objects. As with any OCR object, events have a single
post-slot. Events may also have one or more pre-slots; the actual
number of which is determined by the type of event.

The post-slot of an event can be connected to multiple OCR objects by
connecting the single post-slot to the pre-slots of other OCR objects.
When the conditions are met indicating that the event should trigger
(according to the \emph{trigger rule}\index{trigger rule}), the event
sets its post-slot to \emph{satisfied} therefore establishing an
ordering relationship between the event and the OCR objects linked to
the event. Events therefore play a key role in establishing the
patterns of synchronization required by a parallel
algorithm~\cite{ImSa14-2}.

When an event is satisfied, it can optionally include an attached data block on its
post-slot. Hence, events not only provide synchronization
(control dependences) but they are also the mechanism OCR uses to
establish data flow dependences. In other words, a classic data flow
algorithm defines tasks as waiting until data is ``ready''. In OCR
this concept is implemented through events with attached data blocks.

Given the diversity of parallel algorithms, OCR has defined several
types of events:
\begin{enumerate}
\item \emph{Once event}\index{Event, Once}: The event is automatically
destroyed on satisfaction. Any object that has the Once event as a
pre-condition must already have been created and linked by the time
the Once event is satisfied.

\item \emph{Idempotent event}\index{Event, Idempotent}: The event
exists until explicitly destroyed by a call to
\code{ocrEventDestroy()}. It is satisfied once and subsequent attempts
to satisfy (i.e.\ trigger) the event are ignored.

\item \emph{Sticky event}\index{Event, Sticky}: The event exists until
explicitly destroyed with a call to \code{ocrEventDestroy()}. It is
satisfied once and subsequent attempts to satisfy (i.e.\ trigger) the
event result in an error code being returned when trying to satisfy
the event.
%
%  Vivek writes:  Need to state the meaning of an error in OCR. Does it result in program
% termination, or some sort of error code (since there is no support for exceptions in C),
% or is it simply undefined?
%
%  TGM responds ... yes, I am in violent agreement with Vivek. I just don't know
% how to do this right now in fits in with the overall design of OCR. This should be
% a major discussion point following the apps workshop
% REC: I added a small note saying it is an error code
%
\item \emph{Latch event}\index{Event, Latch}: The latch event has two
pre-slots and triggers when the conditions defined by the latch
trigger rule are met. The event is automatically destroyed once it
triggers; in this regard, it is similar to a \emph{once event}.
\end{enumerate}

Events ``trigger'' when the appropriate \emph{trigger
rule}\index{trigger rule} is met. The default trigger rule for events
is when the link on their pre-slot is satisfied, the event triggers
and passes the state from the pre-slot to its post-slot. For example,
if the pre-slot has an associated data block GUID, that data block
GUID will be propagated through the event's post-slot.

The trigger rule for a latch event is somewhat more complicated. The
latch event has two pre-slots; an increment slot and a decrement
slot. The latch event will trigger its post-slot when the event
receives an equal but non-zero number of satisfy notifications on each
of the pre-slots. Once a latch event triggers, any subsequent
triggers on the pre-slots of the latch event are undefined. For
regular events, when it is triggered with a data block, the GUID of
that data block is passed along through the post-slot of the
event. For a latch event, however, the GUID of a data block that
triggers a pre-slot is ignored.

\subsection{Data Blocks}
\index{Data Block}
\label{sec:datablocks}
Data blocks are OCR objects used to hold data in an OCR program. A
data block is the only way to store data that persists outside of the
scope of a collection of EDTs. Hence, data blocks are the only way to
share data between EDTs. The data blocks are identified by their
GUIDs and occupy a shared name space of GUIDs. While the name space
is shared and globally visible, however, an EDT can only access {\bf a)}
data blocks passed into the EDT through a pre-slot or {\bf b)} a data block
that is created inside the body of the EDT.

When a data block is created, the default behavior is that the EDT
that created the data block will also acquire the data block. This
increments the reference counter for the data block and plays a key
role in managing the memory of an OCR program. Optionally, an EDT can
create a data block on behalf of another EDT. In this case, a
programmer can request that the data block is created, but not
acquired by the EDT.

Conceptually, data blocks are contiguous chunks of memory
that have a start address and a size. They have the following characteristics:
\begin{itemize}
\item all memory within the data block is accessible from the
start-address using an offset, meaning an EDT can manipulate the
contents of a data block through pointers.
\item The contents of different Data blocks are guaranteed to not
overlap.
\item The pointer to the start of a data block is only valid between
the acquire of the data block (implicit when the EDT starts) and the
corresponding \code{ocrDbRelease()} call (or the end of the acquiring
EDT, whichever comes first)
\end{itemize}

Data blocks can be explicitly connected to other OCR objects through the OCR
dependence API (see Chapter~\ref{group__OCRDependences}).
The more common usage pattern, however, is
to attach data blocks to events and pass them through the
directed acyclic graph associated with an OCR program to support a
data-flow pattern of execution.

Regardless of how the data blocks are exposed among a collection of
EDTs, a program may define constraints over how data
blocks can be used.  This leads to several different modes for how an
EDT may access a data block.  The mode is set when the OCR dependences
API is used to dynamically set dependences between a data block and an
EDT. Currently, OCR supports four modes:
\begin{enumerate}

\item \emph{Read-Write} (default mode)\index{Data Block, read-write}: The EDT may read
and write to the data block, but the system will not enforce exclusive access.  Multiple EDTs may
write to the same data bock at the same time.   It is the responsibility of the programmer to
assure that when multiple writers are writing to a read-write data block,
appropriate synchronization
is included to assure that the writes do not conflict.  Note: it is legal for an OCR program
to contain data races.  See section~\ref{sec:MemoryModel} for more information.

\item \emph{Exclusive write}\index{Data Block, exclusive write}: The
EDT requires that it is the only EDT writing to a data block at a
given time. If multiple EDTs are runnable and want to access the same
data block in \emph{exclusive write} mode, the runtime will serialize
the execution of these EDTs.

\item \emph{Read only}\index{Data Block, read only}: The EDT
will only read from the Data Block. The OCR Runtime does
not restrict the ability of other EDTs to write to the data block,
even if the writes from one EDT might overlap with reads by the EDT
with read only access.   If an EDT writes to a data block
it has acquired in constant mode,
the results of those writes are undefined should other EDT's later acquire the same data block.

\item \emph{Constant}\index{Data Block, constant}: The EDT will only read from the
data block and the OCR runtime will assure that once the data block is acquired,
writes from other EDTs will not be visible.  If an EDT writes to a data block
it has acquired in constant mode,
the results of those writes are undefined should other EDT's later acquire the same data block.
\end{enumerate}

% This is the end of ch1-ocr-objects.tex of the OCR specification.
