% This is an included file. See the master file for more information.
%

\section{Execution Model}
\index{Execution Model}
\label{sec:ExecutionModel}

OCR is based on an asynchronous task model.   The work of an OCR program
is defined in terms of a collection of tasks  organized
into a directed acyclic graph (DAG)\index{DAG}~\cite{TaSa11,Tasirlar11,Zuckerman:2011:UCP:2000417.2000424}.
Task execution is managed by the availability of data (the ``data blocks'') and events; hence why
the tasks are called ``Event Driven Tasks'' or EDTs.

An OCR program executes on an abstract machine called the \emph{OCR
Platform}\index{OCR Platform}.  The OCR platform is a resource that can carry out
computations. It consists of:
\begin{itemize}
\item A collection of network connected nodes where any two nodes can
communicate with each other.
\item Each node consists of one or more processing elements each of
which has its own private memory\footnote{By ``private'' we mean a
memory region that is not accessible to other processing
elements.}.
\item Workers that run on the processing elements to execute enqueued EDTs.
\item A globally accessible shared name space of OCR objects each
denoted by a globally unique ID (GUID).
\end{itemize}
OCR is designed to be portable and scalable, hence, the OCR Platform
places minimal constraints on the physical hardware.


%
%  Library mode is an extension so we do not have to settle on the name just yet.
%
%  this whole run-alone vs library-mode concept is broken.  I need
% to come up with the right way to describe this.
%OCR programs can either run alone or be encompassed in other programs
%in a library manner. In the following description, ``OCR program'' refers
%to either the entire OCR program if it is running alone or the OCR
%portion of the program if running library mode.

The OCR program logically starts as a single  EDT called  \code{mainEDT()}.
In other words, the programmer does not provide a \code{main()} function.
The OCR runtime system creates the \code{main()} function on the programmer`s
behalf to set up the
OCR environment and then calls the user provided \code{mainEDT()}. The expected
function prototype for the \code{mainEDT()} is described in section~\ref{sec:mainEDT}.

The DAG corresponding
to the executing program is constructed dynamically and completes when the
\code{ocrShutdown()} or \code{ocrAbort()} function is called.
This rather simple model can handle a wide range of
design patterns including branch and bound, data flow, and divide and
conquer.
%
%Vivek wanted to add a long discussion of how you can use to represent
% SPMD algorithms as well. Once again, given the short time to address this,
% I opted to leave it out. This is a specification not a programmers reference guide. But
% he raised many good points that we need to develop and document somewhere
%

To understand the execution model of OCR, consider the discrete states and
transitions of an executing EDT as defined in figure~\ref{fig:EDTexec}.  An
EDT is created and once its GUID is available for use in API function, the EDT is said
to be \emph{Available}\index{Available}.  At some point, the dependences
are fully defined for the EDT and it becomes \emph{resolved}\index{resolved}.
Note that the transition from Available to Resolved is not called out as a named transition.
This implies that it is not generally possible for the system to set a distinct time-stamp
corresponding to when the transition occurred.  In this case, the transition is un-named
because dependencies may be added dynamically up until the
EDT \emph{Launch}\index{Launch} transition.  At this point point the
EDT is \emph{Runnable}\index{Runable}.

Once an EDT is runnable,  it will execute at some point during the normal execution
of the OCR program.   At some point all data blocks linked to an EDT will be acquired and the
EDT becomes \emph{Ready}\index{Ready}. The
EDT  and any resources required
to support its execution are then submitted to
\emph{workers}\index{Worker}~\cite{GBRS09} which execute the tasks on
the processing elements within the OCR platform. The workers and the
data-structures used to store tasks waiting to execute
(i.e.\ work-pools) are a low level implementation detail not defined by
the OCR specification. When reasoning about locality and load
balancing, programmers may need to explicitly reason about the
behavior of the workers~\cite{Chatterjee13}, but they do not hold
persistent state visible to an OCR program and are logically opaque to
OCR constructs. The scheduler inside the implementation of OCR
will then schedule the EDT for execution and the EDT  \emph{Starts}\index{Start} to execute and
becomes a \emph{Running}\index{Running} EDT.

\begin{figure*}
\centering
 \includegraphics[width=0.9\textwidth]{EDT_exec}
\caption{Observable execution features.}
\label{fig:EDTexec}
\end{figure*}

Normal EDT execution continues until the EDT function returns.   The EDT undergoes
a \emph{Finish}\index{Finish} transition and the EDT is in the \emph{End}\index{End} state.
At some point the EDT will release the data blocks associated with the EDTs execution and the
EDT enters the \emph{Released} state.   At this point, any changes made to data blocks will
be available for use by other OCR objects. Later the EDT will
mark its post-slot as satisfied\index{Satisfied} to \emph{Trigger}\index{Trigger} the event
associated with the EDT; thereby becoming a \emph{Triggered} EDT.  At some later point the
system will \emph{Clean-up}\index{Clean-up} resources used by the EDT (including its GUID) and
the EDT is Destroyed.

Since an EDT is non-blocking, once it
becomes ``runnable'' it will run on the OCR platform at some point in the
future. During its run:
\begin{itemize}
\item The EDT can only access data blocks that have been passed in
through its pre-slots as well as any data blocks that the EDT creates
internally. This means that before an EDT starts, the OCR runtime
knows all the data blocks that will be accessed (minus the ones
created within the EDT).

\item The EDT can call into the runtime to create and destroy data
blocks, EDTs and events.

\item The EDT can create \emph{links} or \emph{dependences}. This is
accomplished through the \code{ocrAddDependence()} function of the OCR
API. The following types of dependences can be created:
\begin{itemize}
\item \emph{Event to Event} The destination event’s pre-slot is chained
directly to the source event’s post-slot.
For all events but the latch event, this means that the triggering of
the source event will trigger the destination event.

\item \emph{Event to EDT} One of the destination EDT’s pre-slot is chained
directly to the source event’s post-slot. When the source event is
triggered, this will satisfy the EDT’s pre-slot. If a data-block was
associated with the triggering of the source event, that data-block
will be made available to the EDT in the dependence array in the
position of the pre-slot. This is a “control + data” dependence. In
the other case, no data-block will be made available and the
dependence is akin to a pure control dependence.

\item \emph{Data Block to Event} Adding a dependence between a data-block and an
event is equivalent to satisfying the event with the data-block.

\item \emph{Data Block to EDT} Directly adding a dependence between a data-block and
an EDT (a pure data-dependence) immediately satisfies the EDT’s
pre-slot and makes the data-block available to the EDT in the
dependence array in the position of the pre-slot.

\end{itemize}

\item The EDT cannot perform any synchronization operations that would
cause it to block inside the body of the task (i.e.\ the EDT must be
non-blocking). The only mechanism for synchronization within OCR is
through the events that link OCR objects, which are explicit to the
runtime.

\end{itemize}

A computation is complete when an EDT terminates the program
(e.g.\ with a call to \code{ocrShutdown()}). Typically, the EDT that
terminates the program is the last EDT in the program DAG, and the
programmer has assured that all other EDTs in the DAG have completed
execution before the function to terminate the program is called.

%The \code{mainEDT()} function has the function prototype:
%  TGM: rob writes ... It is too late to change this now, but it is very unfortunate that types
%  u32 and u64 (which are not defined!) are used for different types of OCR variables.
%  If it becomes necessary to change the type of an OCR variable (which Sanjay, Zoran
%  and I discovered would have been very nice to accommodate hints), all other variables
%  using the same type will also change. In the final spec, i.e. the one to be written
%  after the apps workshop, and which will also do away with the Event object, I propose
%   that we use different opaque data types for all OCR variables.
%\begin{ocrsnip}
%#include <ocr.h>
%
%ocrGuid_t mainEdt(
%             u32 paramc,           // number of parameters for mainEDT
%             u64* paramv,          // array of parameters for mainEDT
%             u32 depc,             // number of dependences for mainEDT
%             ocrEdtDep_t depv[] )  // array of parameters for mainEDT
%{
%    // Put the code for the mainEDT here
%    ocrShutdown();         // shut down OCR once all resources have been released
%    return NULL_GUID;
%}
%\end{ocrsnip}
%The details behind the parameters and dependences are described in
%Chapter~\ref{chap:OCRAPI}.
Since the OCR runtime creates the \code{main()}
function, the programmer doesn't need to manage the low level
details of initializing and cleanly shutting down OCR.
%This approach,
%however, does not work if the programmer wishes to use OCR inside a
%larger body of software perhaps as part of a library that must
%inter-operate with other runtimes. Hence, the OCR specification
%defines a set of functions to support this ``library mode'' of
%launching an OCR program.
%
%In non-library mode (using just \code{mainEdt}), the arguments
%(\code{argc} and \code{argv}) are still communicated through the use
%of the first data block passed into \code{mainEdt}. The programmer can
%use the functions \code{getArgc} and \code{getArgv} to gain access to
%these values. These functions are defined in Chapter~\ref{chap:OCRAPI}.


Links can imply control dependences or, when a data block is
associated with an event, they imply data flow between OCR objects.
In either case, the events constrain the order of execution of EDTs
typically executing the program as a data flow program.

With both data and tasks conceptually decoupled from their realization
on a computer system, OCR has the flexibility to relocate tasks and data
to respond to failures in the system, achieve a better balance of load
among the processing elements of the computer, or to optimize memory
and energy consumption~\cite{GZCS10,Guo10,CTBCCGYS13,SbBS14}.
This requires that the state of an OCR program can be defined
strictly in terms of which tasks have completed their execution
and the history of updates to data blocks. By saving a log of updates to Data Blocks
relative to the Tasks that have completed execution, the system can recover
the state of a computation should components of the system fail.  This requires,
however, that EDTs execute with transactional semantics.

% This is the end of ch1-exec.tex of the OCR specification.
