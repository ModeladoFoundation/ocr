\section{Parameterized event creation}
\label{sec:paramEvents}
This extension allows the user to provide an additional parameter at
the creation of an event to customize its behavior. For example, with
latch events, the user may specify an initial count for the latch.

\subsection{Usage scenarios}
This extension makes the initialization of latch events
simpler. Previously the programmer had to write a loop to increment or
decrement the counter to reach a certain value. The same is now
achieved by passing the counter value as part of the extra parameter.

\subsection{API}
A new API call named
\hyperlink{func_ocrEventCreateParams}{\code{ocrEventCreateParams}}
is added. It has the same signature as
\hyperlink{func_ocrEventCreate}{\code{ocrEventCreate}} with an
additional argument of type \code{ocrEventParams\_t*}. The later is
a struct composed of a union of sub-structure declarations that are
referenced by name, one for each type of event that can be
configured. Note a runtime implementation can make no assumptions
about the lifetime of the passed pointer and must ensure that the
parameter can be safely destroyed by the user after returning from the call.

The following parameters are available for latch events:
\begin{itemize}
\item \code{EVENT\_LATCH}:
\begin{itemize}
\item \code{{\bf u64} counter}: Initial value of the latch counter.
\end{itemize}
\end{itemize}

\subsection*{Functions}
\begin{DoxyCompactItemize}
\item
\hyperlink{type_u8}{u8} \hyperlink{func_ocrEventCreateParams}
{\code{ocrEventCreateParams}}(\hyperlink{type_ocrGuid_t}{ocr\-Guid\-\_\-t}
$\ast$ guid,
\hyperlink{type_ocrEventTypes_t}{ocrEventTypes\_t} eventType,
\hyperlink{type_u16}{u16} properties,
const \hyperlink{type_ocrHint_t}{ocr\-Hint\-\_\-t} $\ast$hint,
const \hyperlink{type_ocrEventParams_t}{ocrEventParams\_t} $\ast$params)
\begin{DoxyCompactList}
  \small \item \emph{DOC TODO}
\end{DoxyCompactList}
\end{DoxyCompactItemize}

%
% ocrEventCreateParams
%
\hypertarget{func_ocrEventCreateParams}{
  \index{Event management@{Event management}!ocr\-Event\-Create@{ocr\-Event\-Create\-Params}}
  \subsection[{ocr\-Event\-Create\-Params}]{\setlength{\rightskip}{0pt plus 5cm}{\bf u8} ocr\-Event\-Create\-Params(
\begin{DoxyParamCaption}
\item[{{\bf ocr\-Guid\-\_\-t} $\ast$}]{guid, }
\item[{{\bf ocr\-Event\-Types\-\_\-t}}]{event\-Type, }
\item[{\bf u16}]{flags, }
\item[{{\bf const ocr\-Hint\_t} $\ast$}]{hint, }
\item[{{\bf const ocr\-Event\-Params\-\_\-t} $\ast$}]{params}
\end{DoxyParamCaption}
)}}
\label{func_ocrEventCreateParams}

Requests the creation of an event of the specified type, initialized
with the provided parameters. After a successful call, the runtime
will return the GUID for the newly created event. The returned GUID is
immediately usable.

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & \code{guid} & On successful creation, contains the GUID of the
event. If the call fails, the returned value is undefined.\\
\hline
\mbox{\tt in}  & \code{eventType} & The type of event to create.
See \hyperlink{type_ocrEventTypes_t}{enum ocrEventTypes\_t}.\\
\hline
\mbox{\tt in}  & \code{flags} & Flags impacting the creation of the event. Currently,
the following flags are supported:
\begin{DoxyItemize}
\item EVT\_PROP\_NONE: Default behavior
\item EVT\_PROP\_TAKES\_ARG: The created event will potentially
  carry a data block on satisfaction.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & \code{hint} & Reserved for future use. This parameter
should be NULL\_HINT. \\
\hline
\mbox{\tt in}  & \code{params} & Parameters to initialized the event with.\\
\hline

\end{DoxyParams}

\returns
0 if no immediate error was detected or the following error codes:
\begin{DoxyItemize}
\item OCR\_ENOMEM ({\bf deferred}): The runtime could not create the event due to insufficient memory
\item OCR\_EINVAL ({\bf immediate}): The \code{eventType} argument is invalid or incompatible
  with \code{flags}
\end{DoxyItemize}

\descr
This function is used to create the basic synchronization mechanism is
OCR: the event. The lifetime of the created event is dependent on its
type. See Section~\ref{sec:Event} for more details.

\section{Counted events}
\label{sec:countedEvents}
A \emph{counted event}\index{Event, counted} will destroy itself
automatically after both of the following conditions are true: {\bf
  a)} it has been satisfied and {\bf b)} a pre-determined number of
OCR objects have a dependence on the event. In other words, a counted
event is like a once event in the sense that it auto-destroys once
satisfied but is safer than a once event because it will expect to
have a certain number of dependences waiting on it and will ensure
that those dependences are satisfied before destroying itself. This
eliminates the necessity for programmers to ensure that all add
dependences that have the once event as a source happen before
satisfying the event.

Counted events trigger immediately when satisfied. Precisely, a
satisfy call triggers the event immediately which will, in turn,
satisfy any dependence already registered at that time. Calls to
\hyperlink{func_ocrAddDependence}{\code{ocrAddDependence}} that happen
after the satisfy call, immediately turn into satisfy calls
themselves. The event is destroyed when it has been satisfied and the
count of expected dependences is reached.

\subsection{API}

Counted events extend the
\hyperlink{type_ocrEventTypes_t}{\code{enum ocrEventTypes\_t}} type
with a OCR\_EVENT\_COUNTED\_T declaration. Counted events rely on the
parameterized event creation extension (see
Section~\ref{sec:paramEvents} to allow the programmer to
specify the number of dependences the counted event will have. A
counted event's parameters are accessible under the EVENT\_COUNTED field
of the ocrEventParams\_t type.

The following parameters are available for counted events:
\begin{itemize}
\item \code{EVENT\_COUNTED}:
\begin{itemize}
\item \code{{\bf u64} nbDeps}: Expected number of dependences to be added to the event.
\end{itemize}
\end{itemize}

Note it is an error to create a counted event with zero dependences.

\section{Channel events}
Channel events represent a whole new class of OCR events that can
trigger multiple times. We define a \emph{generation} as the time
between consecutive triggers of the event (the first generation is
defined as the time between the event creation and its first trigger).

Channel events have a different triggering rule; a channel event will
trigger when both the following conditions are met: {\bf a)} the event
has been satisfied a certain number of times and {\bf b)} a certain
number of dependences has been added to the event. Once a channel
event triggers, the event is reset and a new generation starts.

Channel events also preserve FIFO ordering when
there is a sequenced-before or happen-before relationship between two
satisfy calls made on the same channel event GUID. Note that the ordering
is only guaranteed when using the GUID of the channel event; any
indirection through other types of events may break the ordering.

\subsection{Usage scenarios}
The current implementation is restricted and defines a generation as
one satisfy paired with one dependence being added. This extension
is meant to explore the usefulness of channel events before a more
general model is defined and implemented. The
implementation provides a `window' of generations in the form of an
internal bounded buffer for which the size is known at the creation of
the channel event. This essentially translates into the implementation
being able to buffer a number of satisfy calls that do not yet have a
matching dependence registered (and vice-versa) up to the bound
value. In order to not exceed the bound, the programmer must enforce
proper synchronization.

The current implementation is geared toward use-cases found in
domain-decomposition applications where each domain communicates its
halo to its neighbor at each iteration of the algorithm. A typical
implementation is to represent each sub-domain and iteration as an EDT
that depends on a set of data blocks for its own domain as well as
data blocks corresponding to
contributions from its neighbor domains. In such situations, where the
communication pattern is static, it
is beneficial to setup a topology of channel events once during the
startup of the application and keep reusing the same event GUIDs to
satisfy the neighbors' upcoming EDT iteration instances.

\subsection{API}

Channel events extend the
\hyperlink{type_ocrEventTypes_t}{\code{enum ocrEventTypes\_t}} type
with an OCR\_EVENT\_CHANNEL\_T declaration. Channel events also rely
on the parameterized event creation extension to allow the programmer
to customize the type of channel event. A channel event's parameters are
accessible under the EVENT\_CHANNEL field of the ocrEventParams\_t
type. Note the actual parameters and their semantic are still under
active development.

The following parameters are available for channel events:
\begin{itemize}
\item \code{EVENT\_CHANNEL}:
\begin{itemize}
\item \code{{\bf u32} maxGen}: The maximum number of generations the event can buffer.
\item \code{{\bf u32} nbSat}: The number of satisfy required to trigger.
  Currently must be set to 1.
\item \code{{\bf u32} nbDeps}: The number of dependences required to
  trigger. Currently must be set to 1.
\end{itemize}
\end{itemize}

\section{Collective events}
\label{sec:collectiveEvents}

Collective operations are a staple of Single Programming Multiple Data (SPMD)
programming style, most exemplified by MPI. Collective operations in OCR are
expressed through adding dependences between OCR objects and satisfying OCR events.
For instance, a broadcast operation is equivalent to satisfying an OCR event with a
datablock and having dependences established between the OCR event and other consumer
OCR objects. Similar OCR object assembly can be constructed to represent traditional
collective operations such as reductions, scatter and gather patterns. However, OCR differs
from SPMD programming style in that there is no notion of `rank' and notion that all the `ranks'
would participate in a collective operation.
Expressing those patterns in terms of OCR object assemblies is a very repetitive chore.
Additionally, it requires to organize and coordinate the associated DAG construction which
can be cumbersome to program. Hence, a user-level `reduction' library has been used to perform
reductions in various OCR applications, improving the productivity of programmers.

We propose an extension to the OCR specification based on extending the concept of events to
accommodate collective operations. A collective event is defined as having `i' input slots (islots)
and `o' output slots (oslots). It is reusable, meaning once created and instantiated, its GUID can be
used to carry out multiple reductions and can trigger multiple times. We propose to support three
collective operations: broadcast, reduce and all reduce. A number of operators such as min, max,
add, multiply, and, or, xor, on both four and eight bytes data types are supported. Further API and
implementation work could easily include support for all gather, scatter and gather types
of operations.
A collective event can be configured at its creation time to specify the collective
operation, types, operators and other parameters. These parameters are immutable,
meaning a collective event instance cannot be repurposed for other operations or operators.

The collective event is better used in SPMD-like codes, where multiple EDTs
are created and execute concurrently, representing a sub-domain of an application,
similarly to MPI ranks. We name such EDTs: `rank EDTs'. In that context, each rank
EDT contributes to a specific i/o slot of the collective event. Generally speaking,
a satisfy operation on an islot allows to participate in the collective operation,
while an ocrAddDependence on an oslot allows to depend on the completion of the
operation. The result of the operation, if any, is available in a datablock
passed through the satisfied dependence.
We define a phase, as being one instance of a collective operation invoked by
a rank EDT. The phase may include both adding a dependence to the event
and satisfying it depending on the collective operation invoked.
Additionally, the phase concept is decoupled from having the collective event trigger.

For an all-reduce operation, each rank EDT is responsible for first adding itself
as a dependence on the event's corresponding oslot, then contribute its reduction
value through a satisfy on the event's corresponding islot. The event will
trigger on all its oslots when it has received all the islot contributions
and has performed the reduction. For a given rank EDT, a phase is done
when it has both added a dependence to and satisfied the event.

For a reduce operation, each rank EDT is responsible for contributing its
reduction value through a satisfy on the event's corresponding islot. Only a
single EDT per phase may add itself as a dependence on its own oslot. The event
will fire on that single oslot when it has received all the islot contributions
and has performed the reduction. If the programmer decides to add a dependence
to multiple rank EDTs, the behavior is undefined. For the target rank EDT, a phase
is done when it has both added a dependence to and satisfied the event. For
other contributors, a phase is done as soon as the event is satisfied.

For a broadcast operation, each rank EDT is responsible for adding itself
as a dependence on the event's corresponding oslot, while a single EDT is
responsible for contributing a broadcast value on its own islot. For the
broadcaster rank EDT, a phase is done when it has satisfied the event.
For other contributors, a phase is done after a dependence has been added to the event.

\subsection{API}

Collective events require extending the ocrAddDependence API call with a source slot
in addition to a destination slot. The ocrAddDependenceSlot API call allows to specify which output slot
to set up a dependence, from a given collective event GUID.

% \hypertarget{func_ocrAddDependenceSlot}{
%   \index{Dependence management@{Dependence management}!ocr\-Add\-Dependence@{ocr\-Add\-Dependence}}
%   \subsection[{ocr\-Add\-DependenceSkit}]{\setlength{\rightskip}{0pt plus 5cm}{
 {\bf u8} ocr\-Add\-DependenceSlot(
\begin{DoxyParamCaption}
\item[{{\bf ocr\-Guid\-\_\-t}}]{source, }
\item[{{\bf u32}}]{sslot, }
\item[{{\bf ocr\-Guid\-\_\-t}}]{destination, }
\item[{{\bf u32}}]{dslot, }
\item[{{\bf ocr\-Db\-Access\-Mode\-\_\-t}}]{mode}
\end{DoxyParamCaption}
)
%}}
% \label{func_ocrAddDependenceSlot}

Non implementation-specific arguments to the collective event creation are:
\begin{itemize}
\item \code{EVENT\_COLLECTIVE}:
\begin{itemize}
\item \code{{\bf u16} nbDatum}: Expected number of datum provided by each contributor.
\item \code{{\bf redOp\_t} op}: The operation to be applied to the collective if any.
\item \code{{\bf collectiveType\_t} type}: The type of collective to be invoked.
\end{itemize}
\end{itemize}

Where the type of collective to be invoked is:
\begin{itemize}
\item \code{collectiveType\_t}:
\begin{itemize}
\item \code{COL\_REDUCE}: A collective of type reduce.
\item \code{COL\_ALLREDUCE}: A collective of type all-reduce.
\item \code{COL\_BROADCAST}: A collective of type broadcast.
\end{itemize}
\end{itemize}

Where the reduction operation is:
\begin{itemize}
\item \code{redOp\_t}:
\begin{itemize}
\item \code{REDOP\_F8\_ADD}
\item \code{REDOP\_F8\_MULT}
\item \code{REDOP\_F8\_MIN}
\item \code{REDOP\_F8\_MAX}
\item \code{REDOP\_U8\_ADD}
\item \code{REDOP\_U8\_MULT}
\item \code{REDOP\_U8\_MIN}
\item \code{REDOP\_U8\_MAX}
\item \code{REDOP\_U8\_BITAND}
\item \code{REDOP\_U8\_BITOR}
\item \code{REDOP\_U8\_BITXOR}
\item \code{REDOP\_S8\_MIN}
\item \code{REDOP\_S8\_MAX}
\item \code{REDOP\_F4\_ADD}
\item \code{REDOP\_F4\_MULT}
\item \code{REDOP\_F4\_MIN}
\item \code{REDOP\_F4\_MAX}
\item \code{REDOP\_U4\_ADD}
\item \code{REDOP\_U4\_MULT}
\item \code{REDOP\_U4\_MIN}
\item \code{REDOP\_U4\_MAX}
\item \code{REDOP\_S4\_MIN}
\item \code{REDOP\_S4\_MAX}
\item \code{REDOP\_U4\_BITAND}
\item \code{REDOP\_U4\_BITOR}
\item \code{REDOP\_U4\_BITXOR}
\end{itemize}
\end{itemize}

The naming convention for the reduction operation is as follows: `REDOP\_'
followed by the primitive type of the operands, followed by the operation
to apply when performing the reduction.

The primitive type `F',`U',`S', respectively refer to a floating point,
an unsigned integer or a signed integer, while `4' and `8' relates to a
four or eight bytes wide type.
The operation applied `ADD', `MULT', `MIN', `MAX', `BITAND', `BITOR' and `BITXOR'
respectively refer to the addition, multiplication, minimum, maximum
and bitwise and, or and exclusive or.