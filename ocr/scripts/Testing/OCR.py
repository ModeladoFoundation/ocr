#!/usr/bin/env python
import argparse
##########################################################################
# OCR.py
# Framework for generating simple OCR programs with a given topology
# PT: This is a work in progress
##########################################################################
CHATTY = True

ADD_HINTS = False
SCRIPT    = __file__

def parse_args(calling_script):
    #call this function after you import OCR.py
    global ADD_HINTS
    global SCRIPT
    parser = argparse.ArgumentParser(description="Generates OCR test programs")
    parser.add_argument("-a", "--hints",dest="add_hints", action="store_true", default=False)
    args = parser.parse_args()
    ADD_HINTS = args.add_hints
    SCRIPT    = calling_script
    return args


#python has no built-in list flattner(!)
#def flatten(l):
#    return flatten(l[0]) + (flatten(l[1:]) if len(l) > 1 else []) if type(l) is list else [l]
def flatten(lis):
    """Given a list, possibly nested to any level, return it flattened."""
    new_lis = []
    for item in lis:
        if type(item) == type([]):
            new_lis.extend(flatten(item))
        else:
            new_lis.append(item)
    return new_lis

class Indent(object):
    tab = 3
    def __init__(self,level=0):
        self.level = level
    def to_s(self):
        return " "*self.level*Indent.tab
    def __str__(self):
        return self.to_s()
    def inc(self):
        self.level += 1
    def dec(self):
        self.level -= 1

class Scope(object):
    #objs is a list of OCR objects in this scope
    def __init__(self, objs):
        self.objs = objs


#toplevel scope
class OCR_prog(object):
    top_scope = []
    def __init__(self,scope=[]):
        self.prog_str  = '#include "ocr.h"\n'
        self.prog_str += "/* Generated by: "+SCRIPT+"\n"
        if SCRIPT != __file__:
            with open(SCRIPT,'r') as script_file:
                script_contents = script_file.read()
            self.prog_str += script_contents
        self.prog_str += "*/\n"
        self.scope    = scope

    def cat(self, s):
        self.prog_str += "\n"+str(s)

    def to_str(self):
        self.do_decls()
        #self.prog_str += "\n"
        #self.prog_str += "ocrGuid_t mainEdt(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[]) {\n"
        #self.prog_str += "}\n"
        return self.prog_str

    def do_decls(self):
        self.prog_str += "\n".join(OCR_prog.top_scope)
        #for i in range(OCR_prog.scope):



class DB(object):
    data_type = "int" #for now
    prop      = "DB_PROP_NONE" #for now
    hint      = "NULL_HINT" #for now
    alloc     = "NO_ALLOC" #for now
    def __init__(self,name,size=1):
        self.name      = name
        self.db_name   = name+"_guid"
        self.data_ptr  = name+"_ptr"
        self.size      = size
        self.deps      = [] #klude: fix this
        self.out_event = self.db_name #of course DBs don't have out_events TODO: rename
        self.paramc    = 0

    def decl(self):
        decl_str  = "ocrGuid_t "+self.db_name+"; "
        decl_str += "int* "+self.data_ptr+";\n"
        return decl_str

    def template(self): #no Template, do nothing
        return ""

    def create(self):
        decl_str  = "ocrDbCreate(&"+self.db_name+", (void**)&"+self.data_ptr+", "+str(self.size)+"*sizeof("+DB.data_type+"),"+DB.prop+", "+DB.hint+", "+DB.alloc+");\n"
        return decl_str

    def init(self):
        decl_str = "for(ii = 0; ii<"+str(self.size)+"; ii++) "+self.data_ptr+"[ii]=ii;\n"
        return decl_str

    def add_dependencies(self):
        return "" #kludgy but needed for the duck typing


class Param(object):
    def __init__(self,name,val):
        self.name = name
        self.val  = val
        self.len  = len(val) if isinstance(val,list) else 1


class EDT(object):
    args="u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[]"
    names=[]
    inst_num=0
    def __init__(self,name="main",params=[],deps=[],scope=[],ret_db=False,op="+",finish=False):
        #if name in EDT.names:
        #   print "// "+name+" already exists"
        self.params    = params
        self.paramc    = len(params) if isinstance(params,list) else params.len
        if self.paramc == 0:
           self.param_name = "NULL"
        else:
           if isinstance(params, list):
              self.param_name = "".join([p.name for p in self.params])
           else:
              self.param_name = params.name
        #self.param_name= "NULL" if self.paramc==0 else ( ("".join([p.name for p in self.params])) if isinstance(self.params,list) else self.params.name)
        self.deps      = flatten(deps)
        self.depc      = len(deps)
        self.name      = name
        EDT.names.append(name)
        self.edt_name  = "edt_"+name
        self.fn_name   = name+"Edt"
        self.templ_name = self.name+"_template"
        self.out_event = self.name+"_out_event"
        self.proto     = "ocrGuid_t "+self.fn_name+"("+EDT.args+")"
        self.scope     = flatten(scope) #list of objects within the scope of this EDT func
        self.finish    = finish
        self.ret_db    = ret_db
        #self.edt_str   = self.func()
        self.compute   = False if self.depc==0 else True  #not considering params at this point
        self.op        = op
        #ret_db is a db created in-scope, initialized and passed along by return
        self.preslot_num = 0
        EDT.inst_num   += 1
        self.spawner   = False
        self.needs_hint_decl = False
        for ocr_obj in self.scope:
           if isinstance(ocr_obj,EDT):
               self.spawner = True
        self.edt_str   = self.func()

    def __str__(self):
        return self.edt_str

    def decl(self):
        decl_str  =  "ocrGuid_t "+", ".join([self.edt_name,
                                             self.templ_name,
                                             self.out_event]) +";\n";
        return decl_str

    def param_decl(self):
        if isinstance(self.params,list):
            values = ",".join([str(p.val) for p in self.params])
        else:
            values = ",".join([str(p) for p in self.params.val])
        pd_str = "u64 "+ self.param_name+"["+str(self.paramc)+"] = {"+values+"};\n"
        return pd_str

    def template(self):
        templ_str = "ocrEdtTemplateCreate(&"+", ".join([self.templ_name,
                                                       self.fn_name,
                                                       str(self.paramc),
                                                       str(self.depc)])+");\n"
        return templ_str

    def create(self):
        hint = "&spawnHint" if(self.spawner and ADD_HINTS) else "NULL_HINT"
        create_str = "ocrEdtCreate(&"+", ".join([self.edt_name,
                                            self.templ_name,
                                            str(self.paramc),
                                            self.param_name,
                                            "EDT_PARAM_DEF",
                                            "NULL", #use addDependencies
                                            "EDT_PROP_FINISH" if(self.finish or self.spawner) else "EDT_PROP_NONE",
                                            hint,
                                            "&"+self.out_event])+");\n"
        return create_str

    #TODO: need to ensure the dependencies are in the same scope (proper construction)
    def add_dependencies(self,indent=""):
        deps_str = ""
        for ocr_obj in reversed(self.scope):
           for dep in ocr_obj.deps:
              if dep in self.scope:
                 deps_str += indent+"ocrAddDependence("+",".join([dep.out_event,
                                                       ocr_obj.edt_name,
                                                       str(ocr_obj.preslot_num),
                                                       "DB_DEFAULT_MODE" #for now
                                                       ]) +");\n"
                 ocr_obj.preslot_num += 1 #this should never happen on a DB
              else:
                 raise RuntimeError(dep.out_event+" not in same scope as "+ocr_obj.edt_name)
        #now clear the preslot_num for each obj in case they get reused
        for ocr_obj in reversed(self.scope):
           for dep in ocr_obj.deps:
              if dep in self.scope:
                 ocr_obj.preslot_num = 0 #this should never happen on a DB
        return deps_str

    def walk_scope(self,level=0):
        level+=1
        func_str = ""
        for ocr_obj in self.scope:
           print " ----------- level "+str(level)+"-------------  "
           print " ocr_obj: "+ocr_obj.edt_name
           print " next in scope: "
           func_str += str(level*3*" ")+ocr_obj.decl()
           func_str += str(level*3*" ")+ocr_obj.template()
           func_str += str(level*3*" ")+ocr_obj.create()
           ocr_obj.walk_scope(level)
        print func_str

    #functions must be pre-declared in the toplevel scope (OCR_prog.top_scope)
    def func(self):
        ch_dbs = filter(lambda obj: isinstance(obj,DB), self.scope)
        i = Indent()
        func_str     = str(i)+self.proto + "{\n"
        i.inc()
        if self.spawner:
           func_str += str(i)+"// Spawns EDTs\n"
        decl_str    = ""
        create_str  = ""
        templ_str   = ""

        for ocr_obj in self.scope:
           if isinstance(ocr_obj, EDT):
               if ocr_obj.spawner:
                  self.needs_hint_decl = True
        if self.needs_hint_decl and ADD_HINTS:
           func_str +=   str(i)+"u64 hintVal = 1;\n"
           func_str +=   str(i)+"ocrHint_t spawnHint;\n"
           func_str +=   str(i)+"ocrHintInit(&spawnHint, OCR_HINT_EDT_T);\n"
           func_str +=   str(i)+"ocrSetHintValue(&spawnHint, OCR_HINT_EDT_SPAWNING, hintVal);\n"
        if len(ch_dbs) > 0:
           func_str +=   str(i)+"int ii=0;\n"
        if CHATTY:
           func_str +=   str(i)+"PRINTF(\"Starting "+self.edt_name+"\\n\");\n"
        for ocr_obj in self.scope:
           decl_str += str(i)+ocr_obj.decl()
           if ocr_obj.paramc > 0:
              decl_str += str(i)+ocr_obj.param_decl()
           if isinstance(ocr_obj,EDT):
              templ_str += str(i)+ocr_obj.template()
           create_str += str(i)+ocr_obj.create()
           if isinstance(ocr_obj,DB):
               create_str +=str(i)+ocr_obj.init()

        func_str += decl_str
        func_str += templ_str+create_str
        func_str += self.add_dependencies(str(i))
        if self.depc > 0:
           func_str += str(i)+"/* Add Computation code for acting on DBs here */\n\n"
           #TODO: what if there are multiple DBs?
           #TODO: what if dep is not a DB? (need to loop over deps)
           dbs = filter(lambda obj: isinstance(obj,DB), self.deps)
           if(len(dbs) > 0):
               func_str += str(i)+"u64 sum = 0;\n"
               func_str += str(i)+"int i = 0;\n"
           for depnum,dep in enumerate(self.deps):
               if isinstance(dep,DB):
                   dbPtr = "dbPtr"+str(depnum)
                   func_str += str(i)+"u32* "+dbPtr+" = (u32*)depv["+str(depnum)+"].ptr;\n"
                   func_str += str(i)+"for(i = 0; i < "+str(dep.size)+"; i++){\n"
                   i.inc()
                   func_str += str(i)+dbPtr+"[i] = "+dbPtr+"[i]+(i*i);\n";
                   func_str += str(i)+"sum+="+dbPtr+"[i];\n"
                   i.dec()
                   func_str += str(i)+"}\n";
               elif isinstance(dep,EDT):
                   pass

           if(len(dbs) > 0):
               func_str += str(i)+"PRINTF(\""+self.edt_name+" sum is: %u\\n\",sum);\n"

        #if self.fn_name == "mainEdt":
        if self.finish:
           func_str += "\n"
           func_str += str(i)+"PRINTF(\"!! "+self.edt_name+" exectute ocrShutdown() !!\\n\");\n"
           func_str += str(i)+"ocrShutdown();\n"
        else:
           pass

        if self.ret_db:
           #can only return on db guid, may as well be the first:
           func_str += str(i)+"return "+ch_dbs[0].db_name+";\n"
        else:
           func_str += str(i)+"return NULL_GUID;\n"
        i.dec()
        func_str +=   str(i)+"}\n"
        OCR_prog.top_scope.append(func_str)
        return func_str



if __name__ == "__main__":
    parse_args(__file__)
#Example program topology:
    prog = OCR_prog()
#    foo_edt = EDT("foo")
#    boo_edt = EDT("Boo") #leaf EDT
#    main_db = DB("db",2)
#    main_edt =EDT("main",scope=[
#                  #OCR objects in the scope of main:
#                  main_db,
#                       #params can be specified with either a number of params (2 below):
#                  EDT("bar", params=[Param("length",2)],deps=[foo_edt,main_db],scope=[
#                       #or params can be specified by a list of values ([1,2,3,4,5] below):
#                       EDT("Baz",params=Param("bazes",[1,2,3,4,5]),scope=[boo_edt]),
#                       #use a list comprehension to create multiple EDTs within a scope:
#                       EDT("Div",scope=[ EDT("Mult"+str(n),op="*") for n in range(0,3) ],op="/")
#                  ]),
#                  foo_edt,
#              ])
    blocks     = 2#4
    xes_per_blk= 4#8
    db_size    = 1024
    num_edts   = blocks*xes_per_blk*4
    main_dbs   = [ DB("db_"+str(n),db_size)                for n in range(0,num_edts) ]
#    child_edts = [ EDT("child"+str(i)) for i in range (0,xes_per_blk)]
#    child_joiner = EDT("child_join", deps=child_edts)
#    comp_edts  = [ EDT("comp_"+str(n), deps=[main_dbs[n]], scope=[child_joiner,child_edts]) for n in range(0,num_edts) ]
    comp_edts  = [ EDT("comp_"+str(n), deps=[main_dbs[n]]) for n in range(0,num_edts) ]
    main_edt   = EDT("main", scope=[
                        main_dbs,
                        comp_edts,
                        EDT("joiner", deps=comp_edts, finish=True)
                 ])
    print prog.to_str()

